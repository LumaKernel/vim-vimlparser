
Describe Async.Promise.Hack
  Before all
    let Promise0 = vital#vital#import('Async.Promise')
    let Promise = vital#vital#import('Async.Promise.Hack')
    call Promise.set_debug(1)
  End

  Describe .new()
    It echos throwed error
      redir => mes
        call Promise.new({resolve, reject -> [execute("throw 'error from throw'"), 0][-1]}, 10)
        sleep 200m
      redir END
      Assert Match(mes, '\CError detected while processing')
      Assert Match(mes, '\cerror from throw')
    End
    It echos rejected error
      redir => mes
        call Promise.new({resolve, reject -> [reject('reject from new'), 0][-1]}, 10)
        sleep 200m
      redir END
      Assert Match(mes, '\creject from new')
    End
  End

  Describe .resolve()
    It echos throwed error of invalid Ex command
      function! s:_test() abort
        _bar
      endfunction
      redir => mes
        call Promise.resolve('foo', 10)
              \.then({val -> s:_test()})
              \.catch(Promise.get_default_error_handler())
        sleep 200m
      redir END
      Assert Match(mes, '\CError detected while processing')
      Assert Match(mes, '\C_bar')
    End
  End

  Describe .reject()
    It echos rejected error
      redir => mes
        call Promise.reject('reject from Promise.reject()', 10)
        sleep 200m
      redir END
      Assert Match(mes, '\Creject from Promise.reject()')
    End
  End

  It extends promise features
    for key in keys(Promise0)
      if type(Promise0[key]) == v:t_func
        call themis#log(key)
        Assert True(has_key(Promise, key))
      endif
    endfor
  End
End

